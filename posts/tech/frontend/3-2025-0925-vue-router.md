---
title: "Vue Router 路由系统详解"
date: "2025-09-25"
description: "深入解析 Vue Router 路由系统的工作原理、配置方式、导航守卫、动态路由等核心概念和最佳实践"
tags: ["Vue", "Vue Router", "SPA", "前端路由", "导航守卫"]
---

# Vue Router 路由系统详解

## 前端路由的原理

### SPA 路由机制

**传统多页应用 vs 单页应用**:
```javascript
// 传统多页应用 (MPA)
/*
用户访问 /about
↓
浏览器发送请求到服务器
↓
服务器返回 about.html
↓
浏览器重新加载页面
*/

// 单页应用 (SPA)
/*
用户点击 /about 链接
↓
JavaScript 拦截点击事件
↓
更新浏览器 URL (不刷新页面)
↓
根据 URL 渲染对应组件
↓
页面内容更新 (无刷新)
*/

// 前端路由实现原理
class SimpleRouter {
  constructor() {
    this.routes = {};
    this.currentRoute = '';
    
    // 监听 URL 变化
    window.addEventListener('popstate', this.handlePopState.bind(this));
    window.addEventListener('hashchange', this.handleHashChange.bind(this));
  }
  
  // Hash 模式路由
  handleHashChange() {
    const hash = window.location.hash.slice(1);
    this.navigate(hash);
  }
  
  // History 模式路由
  handlePopState(event) {
    const path = window.location.pathname;
    this.navigate(path);
  }
  
  // 注册路由
  route(path, component) {
    this.routes[path] = component;
  }
  
  // 导航到指定路由
  navigate(path) {
    this.currentRoute = path;
    const component = this.routes[path];
    
    if (component) {
      this.render(component);
    } else {
      this.render(this.routes['/404'] || 'Page Not Found');
    }
  }
  
  // 渲染组件
  render(component) {
    const app = document.getElementById('app');
    if (typeof component === 'function') {
      app.innerHTML = component();
    } else {
      app.innerHTML = component;
    }
  }
  
  // 编程式导航
  push(path) {
    // History 模式
    window.history.pushState({}, '', path);
    this.navigate(path);
    
    // Hash 模式
    // window.location.hash = path;
  }
}

// 使用示例
const router = new SimpleRouter();

router.route('/', () => '<h1>Home Page</h1>');
router.route('/about', () => '<h1>About Page</h1>');
router.route('/contact', () => '<h1>Contact Page</h1>');

// 初始化
router.navigate(window.location.pathname);
```

### Hash 模式 vs History 模式

```javascript
// Hash 模式特点
const hashModeFeatures = {
  url: 'http://example.com/#/user/123',
  
  advantages: [
    '兼容性好，支持所有浏览器',
    '无需服务器配置',
    '不会向服务器发送 hash 部分'
  ],
  
  disadvantages: [
    'URL 中有 # 符号，不够美观',
    'SEO 不友好',
    '无法使用锚点定位'
  ],
  
  implementation: `
    // Hash 路由实现
    class HashRouter {
      constructor() {
        window.addEventListener('hashchange', () => {
          const hash = window.location.hash.slice(1);
          this.handleRoute(hash);
        });
      }
      
      push(path) {
        window.location.hash = path;
      }
      
      replace(path) {
        const href = window.location.href;
        const index = href.indexOf('#');
        const newUrl = index >= 0 ? href.slice(0, index) : href;
        window.location.replace(newUrl + '#' + path);
      }
    }
  `
};

// History 模式特点
const historyModeFeatures = {
  url: 'http://example.com/user/123',
  
  advantages: [
    'URL 美观，没有 # 符号',
    'SEO 友好',
    '可以使用锚点定位',
    '支持服务端渲染'
  ],
  
  disadvantages: [
    '需要服务器配置支持',
    '兼容性要求 HTML5',
    '刷新页面可能 404'
  ],
  
  implementation: `
    // History 路由实现
    class HistoryRouter {
      constructor() {
        window.addEventListener('popstate', (event) => {
          this.handleRoute(window.location.pathname);
        });
      }
      
      push(path) {
        window.history.pushState({}, '', path);
        this.handleRoute(path);
      }
      
      replace(path) {
        window.history.replaceState({}, '', path);
        this.handleRoute(path);
      }
    }
  `,
  
  serverConfig: `
    // Nginx 配置
    location / {
      try_files $uri $uri/ /index.html;
    }
    
    // Apache 配置
    <IfModule mod_rewrite.c>
      RewriteEngine On
      RewriteBase /
      RewriteRule ^index\.html$ - [L]
      RewriteCond %{REQUEST_FILENAME} !-f
      RewriteCond %{REQUEST_FILENAME} !-d
      RewriteRule . /index.html [L]
    </IfModule>
  `
};
```

## Vue Router 基础配置

### 路由配置

```javascript
// router/index.js
import { createRouter, createWebHistory, createWebHashHistory } from 'vue-router';
import Home from '@/views/Home.vue';
import About from '@/views/About.vue';

// 路由配置
const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
    meta: {
      title: '首页',
      requiresAuth: false
    }
  },
  {
    path: '/about',
    name: 'About',
    component: About,
    meta: {
      title: '关于我们',
      requiresAuth: false
    }
  },
  {
    path: '/user/:id',
    name: 'User',
    component: () => import('@/views/User.vue'), // 懒加载
    props: true, // 将路由参数作为 props 传递
    meta: {
      title: '用户详情',
      requiresAuth: true
    }
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: {
      title: '控制台',
      requiresAuth: true,
      roles: ['admin', 'user']
    },
    children: [
      {
        path: '',
        name: 'DashboardHome',
        component: () => import('@/views/dashboard/Home.vue')
      },
      {
        path: 'profile',
        name: 'Profile',
        component: () => import('@/views/dashboard/Profile.vue')
      },
      {
        path: 'settings',
        name: 'Settings',
        component: () => import('@/views/dashboard/Settings.vue')
      }
    ]
  },
  {
    // 404 页面
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/NotFound.vue'),
    meta: {
      title: '页面未找到'
    }
  }
];

// 创建路由实例
const router = createRouter({
  // History 模式
  history: createWebHistory(process.env.BASE_URL),
  
  // Hash 模式
  // history: createWebHashHistory(),
  
  routes,
  
  // 滚动行为
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      // 浏览器前进后退时恢复滚动位置
      return savedPosition;
    } else if (to.hash) {
      // 锚点定位
      return {
        el: to.hash,
        behavior: 'smooth'
      };
    } else {
      // 默认滚动到顶部
      return { top: 0 };
    }
  }
});

export default router;
```

### 路由组件

```vue
<!-- App.vue -->
<template>
  <div id="app">
    <!-- 导航栏 -->
    <nav class="navbar">
      <router-link to="/" class="nav-link">首页</router-link>
      <router-link to="/about" class="nav-link">关于</router-link>
      <router-link 
        v-if="isAuthenticated" 
        to="/dashboard" 
        class="nav-link"
      >
        控制台
      </router-link>
      
      <!-- 编程式导航 -->
      <button @click="goToUser(123)">用户详情</button>
    </nav>
    
    <!-- 路由出口 -->
    <main class="main-content">
      <router-view v-slot="{ Component, route }">
        <!-- 路由过渡动画 -->
        <transition :name="route.meta.transition || 'fade'" mode="out-in">
          <component :is="Component" :key="route.path" />
        </transition>
      </router-view>
    </main>
    
    <!-- 嵌套路由出口 -->
    <router-view name="sidebar" />
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useRouter } from 'vue-router';
import { useUserStore } from '@/stores/user';

const router = useRouter();
const userStore = useUserStore();

const isAuthenticated = computed(() => userStore.isAuthenticated);

// 编程式导航
function goToUser(userId) {
  router.push({
    name: 'User',
    params: { id: userId },
    query: { tab: 'profile' }
  });
}
</script>

<style>
/* 路由过渡动画 */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

/* 活跃链接样式 */
.nav-link.router-link-active {
  color: #42b883;
  font-weight: bold;
}
</style>
```

## 动态路由

### 路由参数

```vue
<!-- User.vue -->
<template>
  <div class="user-page">
    <h1>用户详情</h1>
    
    <!-- 路由参数 -->
    <div class="user-info">
      <p>用户ID: {{ $route.params.id }}</p>
      <p>当前标签: {{ $route.query.tab || 'profile' }}</p>
    </div>
    
    <!-- 标签切换 -->
    <div class="tabs">
      <button 
        v-for="tab in tabs" 
        :key="tab.name"
        :class="{ active: currentTab === tab.name }"
        @click="switchTab(tab.name)"
      >
        {{ tab.label }}
      </button>
    </div>
    
    <!-- 标签内容 -->
    <div class="tab-content">
      <UserProfile v-if="currentTab === 'profile'" :user="user" />
      <UserPosts v-else-if="currentTab === 'posts'" :user-id="userId" />
      <UserSettings v-else-if="currentTab === 'settings'" :user="user" />
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { userAPI } from '@/api';

const route = useRoute();
const router = useRouter();

// 响应式数据
const user = ref(null);
const loading = ref(false);

// 计算属性
const userId = computed(() => route.params.id);
const currentTab = computed(() => route.query.tab || 'profile');

// 标签配置
const tabs = [
  { name: 'profile', label: '个人资料' },
  { name: 'posts', label: '发布内容' },
  { name: 'settings', label: '设置' }
];

// 切换标签
function switchTab(tab) {
  router.push({
    name: 'User',
    params: { id: userId.value },
    query: { tab }
  });
}

// 获取用户数据
async function fetchUser(id) {
  loading.value = true;
  try {
    const response = await userAPI.getUser(id);
    user.value = response.data;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    // 用户不存在，跳转到 404
    router.push('/404');
  } finally {
    loading.value = false;
  }
}

// 监听路由参数变化
watch(
  () => route.params.id,
  (newId, oldId) => {
    if (newId !== oldId) {
      fetchUser(newId);
    }
  },
  { immediate: true }
);

// 组件挂载时获取数据
onMounted(() => {
  if (userId.value) {
    fetchUser(userId.value);
  }
});
</script>
```

### 路由匹配

```javascript
// 高级路由匹配
const advancedRoutes = [
  // 可选参数
  {
    path: '/user/:id?',
    component: User,
    // id 参数可选，/user 和 /user/123 都匹配
  },
  
  // 多个参数
  {
    path: '/user/:id/post/:postId',
    component: UserPost,
    // 匹配 /user/123/post/456
  },
  
  // 通配符匹配
  {
    path: '/files/:pathMatch(.*)*',
    component: FileExplorer,
    // 匹配 /files/documents/readme.txt
  },
  
  // 正则表达式约束
  {
    path: '/user/:id(\\d+)', // 只匹配数字
    component: User
  },
  
  // 重复参数
  {
    path: '/chapter/:chapters+', // 一个或多个
    component: Chapter
    // 匹配 /chapter/1 或 /chapter/1/2/3
  },
  
  // 可选重复参数
  {
    path: '/chapter/:chapters*', // 零个或多个
    component: Chapter
    // 匹配 /chapter 或 /chapter/1/2/3
  }
];

// 路由参数处理
const RouteParamsHandler = {
  // 参数验证
  validateParams(route) {
    const { id } = route.params;
    
    if (id && !/^\d+$/.test(id)) {
      throw new Error('Invalid user ID');
    }
    
    return true;
  },
  
  // 参数转换
  transformParams(route) {
    return {
      id: Number(route.params.id),
      tab: route.query.tab || 'profile',
      page: Number(route.query.page) || 1
    };
  },
  
  // 参数序列化
  serializeParams(params) {
    const query = {};
    
    if (params.tab !== 'profile') {
      query.tab = params.tab;
    }
    
    if (params.page > 1) {
      query.page = params.page;
    }
    
    return query;
  }
};
```

## 导航守卫

### 全局守卫

```javascript
// router/guards.js
import { useUserStore } from '@/stores/user';
import { ElMessage } from 'element-plus';

// 全局前置守卫
export function setupGlobalGuards(router) {
  // 身份验证守卫
  router.beforeEach(async (to, from, next) => {
    const userStore = useUserStore();
    
    // 设置页面标题
    if (to.meta.title) {
      document.title = `${to.meta.title} - My App`;
    }
    
    // 检查是否需要身份验证
    if (to.meta.requiresAuth) {
      if (!userStore.isAuthenticated) {
        ElMessage.warning('请先登录');
        next({
          name: 'Login',
          query: { redirect: to.fullPath }
        });
        return;
      }
      
      // 检查用户权限
      if (to.meta.roles && !hasPermission(userStore.user, to.meta.roles)) {
        ElMessage.error('权限不足');
        next('/403');
        return;
      }
    }
    
    // 检查用户状态
    if (to.name === 'Login' && userStore.isAuthenticated) {
      next('/dashboard');
      return;
    }
    
    next();
  });
  
  // 全局解析守卫
  router.beforeResolve(async (to, from, next) => {
    // 在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后调用
    
    // 预加载数据
    if (to.meta.preload) {
      try {
        await preloadRouteData(to);
      } catch (error) {
        console.error('Failed to preload data:', error);
      }
    }
    
    next();
  });
  
  // 全局后置钩子
  router.afterEach((to, from, failure) => {
    // 导航完成后的处理
    
    if (failure) {
      console.error('Navigation failed:', failure);
      return;
    }
    
    // 埋点统计
    trackPageView(to);
    
    // 更新面包屑
    updateBreadcrumb(to);
    
    // 关闭加载状态
    hideGlobalLoading();
  });
}

// 权限检查
function hasPermission(user, requiredRoles) {
  if (!user || !user.roles) return false;
  
  const userRoles = user.roles.map(role => role.name);
  return requiredRoles.some(role => userRoles.includes(role));
}

// 预加载数据
async function preloadRouteData(route) {
  const preloadFunctions = route.meta.preload;
  
  if (Array.isArray(preloadFunctions)) {
    await Promise.all(preloadFunctions.map(fn => fn(route)));
  } else if (typeof preloadFunctions === 'function') {
    await preloadFunctions(route);
  }
}

// 页面访问统计
function trackPageView(route) {
  // 发送统计数据到分析服务
  if (window.gtag) {
    window.gtag('config', 'GA_MEASUREMENT_ID', {
      page_path: route.path,
      page_title: route.meta.title
    });
  }
}

// 更新面包屑
function updateBreadcrumb(route) {
  const breadcrumb = [];
  let currentRoute = route;
  
  while (currentRoute) {
    if (currentRoute.meta.breadcrumb !== false) {
      breadcrumb.unshift({
        name: currentRoute.meta.title || currentRoute.name,
        path: currentRoute.path
      });
    }
    currentRoute = currentRoute.parent;
  }
  
  // 更新全局面包屑状态
  const appStore = useAppStore();
  appStore.setBreadcrumb(breadcrumb);
}
```

### 路由独享守卫

```javascript
// 路由配置中的守卫
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from, next) => {
      // 管理员权限检查
      const userStore = useUserStore();
      
      if (!userStore.user || !userStore.user.isAdmin) {
        next('/403');
        return;
      }
      
      next();
    }
  },
  
  {
    path: '/payment/:orderId',
    component: Payment,
    beforeEnter: async (to, from, next) => {
      // 订单状态检查
      try {
        const orderId = to.params.orderId;
        const order = await orderAPI.getOrder(orderId);
        
        if (order.status !== 'pending') {
          next(`/order/${orderId}`);
          return;
        }
        
        // 将订单信息传递给组件
        to.meta.order = order;
        next();
      } catch (error) {
        next('/404');
      }
    }
  }
];
```

### 组件内守卫

```vue
<!-- UserEdit.vue -->
<template>
  <div class="user-edit">
    <form @submit.prevent="saveUser">
      <input v-model="form.name" placeholder="姓名" />
      <input v-model="form.email" placeholder="邮箱" />
      <button type="submit">保存</button>
    </form>
  </div>
</template>

<script setup>
import { ref, reactive } from 'vue';
import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router';
import { ElMessageBox } from 'element-plus';

const form = reactive({
  name: '',
  email: ''
});

const hasUnsavedChanges = ref(false);

// 监听表单变化
watch(form, () => {
  hasUnsavedChanges.value = true;
}, { deep: true });

// 路由更新守卫
onBeforeRouteUpdate(async (to, from, next) => {
  // 在当前路由改变，但是该组件被复用时调用
  // 例如：从 /user/1 到 /user/2
  
  if (hasUnsavedChanges.value) {
    const confirmed = await confirmLeave();
    if (!confirmed) {
      next(false);
      return;
    }
  }
  
  // 重置表单
  resetForm();
  next();
});

// 路由离开守卫
onBeforeRouteLeave(async (to, from, next) => {
  if (hasUnsavedChanges.value) {
    const confirmed = await confirmLeave();
    if (!confirmed) {
      next(false);
      return;
    }
  }
  
  next();
});

// 确认离开对话框
async function confirmLeave() {
  try {
    await ElMessageBox.confirm(
      '您有未保存的更改，确定要离开吗？',
      '确认离开',
      {
        confirmButtonText: '离开',
        cancelButtonText: '取消',
        type: 'warning'
      }
    );
    return true;
  } catch {
    return false;
  }
}

// 保存用户
async function saveUser() {
  try {
    await userAPI.updateUser(form);
    hasUnsavedChanges.value = false;
    ElMessage.success('保存成功');
  } catch (error) {
    ElMessage.error('保存失败');
  }
}

// 重置表单
function resetForm() {
  form.name = '';
  form.email = '';
  hasUnsavedChanges.value = false;
}
</script>
```

## 路由懒加载与代码分割

### 组件懒加载

```javascript
// 路由懒加载配置
const routes = [
  {
    path: '/',
    name: 'Home',
    // 直接导入 - 会打包到主 bundle
    component: Home
  },
  
  {
    path: '/about',
    name: 'About',
    // 懒加载 - 会分割成独立的 chunk
    component: () => import('@/views/About.vue')
  },
  
  {
    path: '/user/:id',
    name: 'User',
    // 带注释的懒加载 - 自定义 chunk 名称
    component: () => import(
      /* webpackChunkName: "user" */ 
      '@/views/User.vue'
    )
  },
  
  {
    path: '/admin',
    name: 'Admin',
    // 条件懒加载
    component: () => {
      if (process.env.NODE_ENV === 'development') {
        return import('@/views/admin/AdminDev.vue');
      } else {
        return import('@/views/admin/Admin.vue');
      }
    }
  }
];

// 高级代码分割策略
const advancedSplitting = {
  // 按功能模块分割
  userModule: () => import(
    /* webpackChunkName: "user-module" */
    '@/modules/user'
  ),
  
  // 按权限分割
  adminModule: () => import(
    /* webpackChunkName: "admin-module" */
    '@/modules/admin'
  ),
  
  // 按使用频率分割
  commonComponents: () => import(
    /* webpackChunkName: "common" */
    '@/components/common'
  ),
  
  // 第三方库分割
  chartsLibrary: () => import(
    /* webpackChunkName: "charts" */
    'echarts'
  )
};
```

### 预加载策略

```javascript
// 路由预加载管理器
class RoutePreloader {
  constructor(router) {
    this.router = router;
    this.preloadedRoutes = new Set();
    this.preloadQueue = [];
    
    this.setupPreloadStrategies();
  }
  
  setupPreloadStrategies() {
    // 鼠标悬停预加载
    this.setupHoverPreload();
    
    // 空闲时间预加载
    this.setupIdlePreload();
    
    // 可视区域预加载
    this.setupIntersectionPreload();
  }
  
  // 鼠标悬停预加载
  setupHoverPreload() {
    document.addEventListener('mouseover', (event) => {
      const link = event.target.closest('a[href]');
      if (link && this.isInternalLink(link.href)) {
        const route = this.router.resolve(link.href);
        this.preloadRoute(route);
      }
    });
  }
  
  // 空闲时间预加载
  setupIdlePreload() {
    if ('requestIdleCallback' in window) {
      const preloadNext = () => {
        requestIdleCallback(() => {
          if (this.preloadQueue.length > 0) {
            const route = this.preloadQueue.shift();
            this.preloadRoute(route);
            preloadNext();
          }
        });
      };
      
      preloadNext();
    }
  }
  
  // 可视区域预加载
  setupIntersectionPreload() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const link = entry.target;
          const route = this.router.resolve(link.href);
          this.preloadRoute(route);
          observer.unobserve(link);
        }
      });
    });
    
    // 观察所有路由链接
    document.querySelectorAll('a[href]').forEach(link => {
      if (this.isInternalLink(link.href)) {
        observer.observe(link);
      }
    });
  }
  
  // 预加载路由组件
  async preloadRoute(route) {
    const routeKey = route.name || route.path;
    
    if (this.preloadedRoutes.has(routeKey)) {
      return;
    }
    
    try {
      // 预加载路由组件
      if (typeof route.component === 'function') {
        await route.component();
      }
      
      // 预加载子路由
      if (route.children) {
        await Promise.all(
          route.children.map(child => this.preloadRoute(child))
        );
      }
      
      this.preloadedRoutes.add(routeKey);
    } catch (error) {
      console.warn('Failed to preload route:', routeKey, error);
    }
  }
  
  // 判断是否为内部链接
  isInternalLink(href) {
    try {
      const url = new URL(href, window.location.origin);
      return url.origin === window.location.origin;
    } catch {
      return false;
    }
  }
  
  // 添加到预加载队列
  queuePreload(routeName) {
    const route = this.router.getRoutes().find(r => r.name === routeName);
    if (route) {
      this.preloadQueue.push(route);
    }
  }
}

// 使用预加载器
const preloader = new RoutePreloader(router);

// 手动预加载重要路由
preloader.queuePreload('Dashboard');
preloader.queuePreload('UserProfile');
```

## 最佳实践

### 路由设计原则

```javascript
// 路由设计最佳实践
const routeDesignPrinciples = {
  // 1. 语义化路径
  goodPaths: [
    '/users',           // 用户列表
    '/users/123',       // 用户详情
    '/users/123/edit',  // 编辑用户
    '/orders/456',      // 订单详情
    '/products/search'  // 产品搜索
  ],
  
  badPaths: [
    '/page1',          // 无意义
    '/u/123',          // 过于简化
    '/user_detail_123' // 不符合 RESTful
  ],
  
  // 2. 层级结构清晰
  hierarchicalRoutes: {
    path: '/dashboard',
    children: [
      { path: '', component: DashboardHome },
      { path: 'analytics', component: Analytics },
      { path: 'users', component: UserManagement },
      { path: 'settings', component: Settings }
    ]
  },
  
  // 3. 参数命名规范
  parameterNaming: {
    good: '/users/:userId/posts/:postId',
    bad: '/users/:id/posts/:id2'
  }
};

// 路由元信息最佳实践
const routeMetaBestPractices = {
  // 完整的路由元信息
  completeRouteMeta: {
    path: '/users/:id',
    component: UserDetail,
    meta: {
      // 页面标题
      title: '用户详情',
      
      // 权限控制
      requiresAuth: true,
      roles: ['admin', 'user'],
      
      // 面包屑
      breadcrumb: [
        { name: '首页', path: '/' },
        { name: '用户管理', path: '/users' },
        { name: '用户详情', path: '/users/:id' }
      ],
      
      // 缓存控制
      keepAlive: true,
      
      // 过渡动画
      transition: 'slide-left',
      
      // 预加载数据
      preload: [
        (route) => userAPI.getUser(route.params.id),
        (route) => userAPI.getUserPosts(route.params.id)
      ],
      
      // SEO 信息
      seo: {
        description: '查看用户详细信息',
        keywords: ['用户', '详情', '个人资料']
      }
    }
  }
};
```

### 性能优化

```javascript
// 路由性能优化策略
class RoutePerformanceOptimizer {
  constructor(router) {
    this.router = router;
    this.routeCache = new Map();
    this.setupOptimizations();
  }
  
  setupOptimizations() {
    // 路由缓存
    this.setupRouteCache();
    
    // 组件预加载
    this.setupComponentPreload();
    
    // 数据预取
    this.setupDataPrefetch();
  }
  
  // 路由缓存
  setupRouteCache() {
    const originalResolve = this.router.resolve;
    
    this.router.resolve = (to, currentRoute) => {
      const cacheKey = typeof to === 'string' ? to : to.path;
      
      if (this.routeCache.has(cacheKey)) {
        return this.routeCache.get(cacheKey);
      }
      
      const resolved = originalResolve.call(this.router, to, currentRoute);
      this.routeCache.set(cacheKey, resolved);
      
      return resolved;
    };
  }
  
  // 组件预加载
  setupComponentPreload() {
    // 在路由切换前预加载下一个可能的路由
    this.router.beforeEach((to, from, next) => {
      const nextRoutes = this.predictNextRoutes(to);
      nextRoutes.forEach(route => this.preloadComponent(route));
      next();
    });
  }
  
  // 预测下一个可能的路由
  predictNextRoutes(currentRoute) {
    const predictions = [];
    
    // 基于用户行为模式预测
    const userBehavior = this.getUserBehaviorPattern();
    
    // 基于路由层级预测
    if (currentRoute.children) {
      predictions.push(...currentRoute.children);
    }
    
    // 基于历史访问记录预测
    const historicalNext = this.getHistoricalNextRoutes(currentRoute.path);
    predictions.push(...historicalNext);
    
    return predictions;
  }
  
  // 数据预取
  setupDataPrefetch() {
    this.router.beforeResolve(async (to, from, next) => {
      // 并行预取数据
      const prefetchPromises = [];
      
      if (to.meta.prefetch) {
        const prefetchFunctions = Array.isArray(to.meta.prefetch) 
          ? to.meta.prefetch 
          : [to.meta.prefetch];
          
        prefetchFunctions.forEach(fn => {
          prefetchPromises.push(fn(to));
        });
      }
      
      try {
        await Promise.all(prefetchPromises);
      } catch (error) {
        console.warn('Data prefetch failed:', error);
      }
      
      next();
    });
  }
}

// 路由监控和分析
class RouteAnalytics {
  constructor(router) {
    this.router = router;
    this.navigationTimes = new Map();
    this.setupAnalytics();
  }
  
  setupAnalytics() {
    let navigationStart;
    
    this.router.beforeEach((to, from, next) => {
      navigationStart = performance.now();
      next();
    });
    
    this.router.afterEach((to, from) => {
      const navigationEnd = performance.now();
      const duration = navigationEnd - navigationStart;
      
      this.recordNavigation(to, from, duration);
    });
  }
  
  recordNavigation(to, from, duration) {
    const record = {
      from: from.path,
      to: to.path,
      duration,
      timestamp: Date.now()
    };
    
    // 记录导航时间
    if (!this.navigationTimes.has(to.path)) {
      this.navigationTimes.set(to.path, []);
    }
    
    this.navigationTimes.get(to.path).push(duration);
    
    // 发送分析数据
    this.sendAnalytics(record);
  }
  
  sendAnalytics(record) {
    // 发送到分析服务
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/analytics/navigation', JSON.stringify(record));
    }
  }
  
  getAverageNavigationTime(path) {
    const times = this.navigationTimes.get(path) || [];
    if (times.length === 0) return 0;
    
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }
}
```

## 总结

Vue Router 是 Vue.js 生态系统中的核心路由解决方案，提供了：

### 核心特性
1. **声明式路由配置**: 清晰的路由结构定义
2. **动态路由匹配**: 灵活的参数和通配符支持
3. **导航守卫**: 完善的权限控制和数据预加载
4. **代码分割**: 自动的组件懒加载和代码分割
5. **历史模式**: Hash 和 History 两种模式支持

### 最佳实践
1. **合理的路由设计**: 语义化路径和清晰的层级结构
2. **性能优化**: 懒加载、预加载和缓存策略
3. **用户体验**: 过渡动画和加载状态管理
4. **SEO 友好**: 合适的元信息和服务器配置

Vue Router 让单页应用的路由管理变得简单而强大，是构建现代 Web 应用不可或缺的工具。